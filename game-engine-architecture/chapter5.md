# Chapter 5 : 游戏支持系统

## 内存管理\(Memory-management\)

#### 堆栈内存分配器\(StackAllocator\)：

首先申请一大块连续内存（malloc\(\)、全局new、声明全局字节数组）。安排一个指针指向堆栈的顶端，指针以下的内存是已分配的，指针以上的内存是未分配的。分配请求，仅需吧指针往上移动请求所需的字节量。释放请求，只需把指针下移该内存块的字节量（注：不能任意次序释放，必须以分配时相反的次序释放内存）

#### 池分配器：

分配大量同等尺寸的小内存块，由链表存储对应的池指针。

#### 含对齐功能的分配器：

在堆栈分配器的基础上添加了对齐分配函数，可设置对齐偏移量

#### 单帧分配器\(Single-frame allocator\)：

其原理就是堆栈分配器，区别就是在游戏的每帧清空分配器

#### 双帧分配器\(double-buffered allocator\)：

在第i帧分配的内存块用于第\(i+1\)帧。原理就是建立两个单帧分配器，每帧交替使用

## 字符串

### 注意

* 尽量避免字符串类，使用C风格的字符数组形式（字符串类已值传递时需要调用拷贝构造函数。若采用以参考传递或以地址传递则不会有这个问题）
* 管理存储文件的路径可以使用字符串类来提供很多有意义的功能

### 唯一标识符

全局唯一标识符（globally unique identifier, GUID）。

用字符串做唯一标识符比较的速度慢，既要有字符串的表达能力和弹性，又要有整数操作的速度。

字符串散列标识符：将字符串散列，方便做字符串对比。

何时计算散列：

* 运行时
* 预处理（可以在switch中使用字符串，类似于Enum）

字符串扣留：从字符串产生字符串表示的过程，两部分，第一散列字符串，第二存入全局表（以散列值取回原来的字符串）

缺点：

* 速度缓慢：字符串散列很费时间
* 分配内存：存入全局表

